# 機能設計書: pyodide-bridge

## 1. 機能一覧

| ID | 機能 | レイヤー | 優先度 |
|----|------|---------|--------|
| F-01 | Python AST パース | CLI | 必須 |
| F-02 | 型定義エミット (.types.ts) | CLI | 必須 |
| F-03 | Worker エミット (.worker.ts) | CLI | 必須 |
| F-04 | React Hooks エミット (.hooks.ts) | CLI | 必須 |
| F-05 | チェックモード (--check) | CLI | 必須 |
| F-06 | 設定ファイル対応 | CLI | 必須 |
| F-07 | Worker ブートストラップ | Runtime | 必須 |
| F-08 | deepConvertMaps | Runtime | 必須 |
| F-09 | BridgeError | Runtime | 必須 |
| F-10 | Comlink ヘルパー | Runtime | 必須 |
| F-11 | usePyodide Hook | React | 必須 |
| F-12 | 関数別 Hook ファクトリ | React | 必須 |

## 2. 機能詳細

### F-01: Python AST パース

**概要**: Python ソースファイルを解析し、型定義・関数シグネチャ・メタデータを構造化データとして抽出する。

**入力**: Python ソースファイルパス

**出力**: 以下を含む中間表現 (IR)
```typescript
interface ModuleIR {
  moduleName: string
  types: TypeDefinition[]       // TypedDict, Literal
  functions: FunctionDefinition[] // __bridge_exports__ に含まれる関数
  packages: string[]            // __bridge_packages__
}
```

**パース対象**:

| Python 構文 | 抽出内容 |
|-------------|---------|
| `class Foo(TypedDict)` | 型名、フィールド名、フィールド型、total フラグ |
| `Foo = Literal['a', 'b']` | 型エイリアス名、リテラル値リスト |
| `__bridge_exports__` | エクスポート関数名リスト |
| `__bridge_packages__` | 依存パッケージ名リスト |
| `def func(params: T) -> R` | 関数名、引数型、戻り値型 |

**実装方式**: Python の `ast` モジュールを使用したスクリプト。CLI が `python3` を呼び出して JSON を受け取る。

**エラーケース**:
- Python ファイルの構文エラー → パースエラーメッセージと行番号を表示
- `__bridge_exports__` 未定義 → 警告を出して空の関数リストで続行
- エクスポート関数に型アノテーションがない → エラー終了

### F-02: 型定義エミット (.types.ts)

**概要**: IR の型定義から TypeScript 型定義ファイルを生成する。

**生成ルール**:

```
TypedDict (total=True)  → export type Foo = { field: Type; ... }
TypedDict (total=False) → export type Foo = { field?: Type; ... }
Required[T] in total=False → field: T  (? なし)
NotRequired[T] in total=True → field?: T
Literal['a','b'] → export type Foo = 'a' | 'b'
```

**型マッピング**:
- プリミティブ: `int`/`float` → `number`, `str` → `string`, `bool` → `boolean`, `None` → `null`
- コンテナ: `list[T]` → `T[]`, `dict[K,V]` → `Record<K,V>`
- Optional: `Optional[T]` → `T | undefined`
- ユーザー定義型: 同一モジュール内の TypedDict/Literal を参照

**出力例**:
```typescript
// engine.types.ts -- generated by pyodide-bridge (DO NOT EDIT)
export type Status = 'ok' | 'error'
export type InputParams = {
  query: string
  limit?: number
}
export type Result = {
  data: number[]
  status: Status
}
```

### F-03: Worker エミット (.worker.ts)

**概要**: Pyodide をロードし、Python 関数を Comlink 経由で公開する Web Worker ファイルを生成する。

**生成内容**:
1. Pyodide CDN からのロード (`loadPyodide`)
2. `__bridge_packages__` の micropip インストール
3. Python ソースの実行 (`runPython`)
4. 各エクスポート関数の Comlink API ラッパー
5. `Comlink.expose(api)`

**データフロー** (1 関数呼び出しあたり):
```
1. メインスレッドから Comlink 経由で引数を受け取る
2. pyodide.toPy(params) で Python オブジェクトに変換
3. Python 関数を呼び出し
4. pyResult.toJs() で JS オブジェクトに変換
5. deepConvertMaps() で Map → Object に再帰変換
6. エラー辞書パターン検出 → BridgeError として throw
7. 結果を返す
```

**バンドラーアダプター**:

| バンドラー | Python ソース読み込み | Worker 生成方法 |
|-----------|---------------------|----------------|
| Vite | `import src from './engine.py?raw'` | `new URL('./worker.ts', import.meta.url)` |
| Webpack | `import src from '!!raw-loader!./engine.py'` | `new URL('./worker.ts', import.meta.url)` |
| Inline | Python ソースを文字列リテラルとして埋め込み | `URL.createObjectURL(new Blob([...]))` |

### F-04: React Hooks エミット (.hooks.ts)

**概要**: Worker ライフサイクル Hook と関数別 Hook を生成する。

**usePyodide Hook**:
```typescript
function usePyodide(): {
  status: 'loading' | 'ready' | 'error'
  error: Error | null
  api: Remote<BridgeAPI> | null
  retry: () => void
}
```

**関数別 Hook** (例: `useRunQuery`):
```typescript
function useRunQuery(
  api: Remote<BridgeAPI> | null,
  status: PyodideStatus
): {
  result: Result | null
  error: BridgeError | null
  isLoading: boolean
  execute: (params: InputParams) => Promise<void>
}
```

**生成パターン**:
- `__bridge_exports__` の各関数に対して `use{PascalCase(funcName)}` を生成
- Hook 内部で `useState`, `useCallback` を使用
- `api` が null または `status !== 'ready'` の場合、`execute` は no-op

### F-05: チェックモード (--check)

**概要**: 生成済みファイルが最新かを検証する。CI 向け。

**アルゴリズム**:
1. Python ソースから IR を生成
2. IR からメモリ上で TypeScript コードを生成
3. 既存の生成ファイルと比較
4. 差分があれば非ゼロ終了 + 差分ファイル名リストを stderr に出力

### F-06: 設定ファイル対応

**概要**: `pyodide-bridge.config.ts` で複数モジュール・共通設定を管理する。

**スキーマ**:
```typescript
interface BridgeConfig {
  pyodideVersion: string         // Pyodide CDN バージョン
  modules: ModuleConfig[]        // モジュール定義リスト
  react?: boolean                // React Hooks 生成 (default: true)
  bundler?: 'vite' | 'webpack' | 'inline'  // バンドラー種別
}

interface ModuleConfig {
  input: string                  // Python ソースファイルパス
  outdir: string                 // 出力ディレクトリ
}
```

**設定の優先順位**: CLI 引数 > 設定ファイル > デフォルト値

### F-07: Worker ブートストラップ

**概要**: Pyodide のロードと初期化を行うランタイムユーティリティ。

**機能**:
- `loadPyodide()` を CDN から呼び出し
- micropip で `__bridge_packages__` をインストール
- Python ソースを `runPython()` で実行
- 初期化の進捗をメインスレッドに通知

**公開 API**:
```typescript
async function bootstrapPyodide(options: {
  pyodideVersion: string
  packages: string[]
  pythonSource: string
}): Promise<PyodideInterface>
```

### F-08: deepConvertMaps

**概要**: Pyodide の `toJs()` が返す ES6 Map を再帰的に plain Object に変換する。

**変換ルール**:
- `Map` → plain object (`Object.fromEntries`)
- `Array` → 各要素を再帰変換
- プリミティブ → そのまま
- ネストされた Map → 再帰的に変換

**公開 API**:
```typescript
function deepConvertMaps<T>(value: unknown): T
```

### F-09: BridgeError

**概要**: Python 側のエラー辞書パターンを検出し、構造化されたエラーとして throw する。

**Python 側のエラー規約**:
```python
{"error": {"code": "ERROR_CODE", "message": "..."}}
```

**TypeScript 側**:
```typescript
class BridgeError extends Error {
  code: string
  constructor(code: string, message: string)
}

function detectBridgeError(result: unknown): void
// result.error が存在すれば BridgeError を throw
```

### F-10: Comlink ヘルパー

**概要**: Comlink Proxy と React setState の互換性問題を解決する。

**問題**: `Comlink.wrap()` が返す Proxy は `typeof === 'function'` なので、`setState(proxy)` が updater function として解釈される。

**解決策**:
```typescript
function wrapProxy<T>(proxy: T): { ref: T }
function unwrapProxy<T>(wrapped: { ref: T }): T
```

### F-11: usePyodide Hook

**概要**: Worker の生成・初期化・エラーハンドリング・再試行を管理する汎用 Hook。

**状態遷移**:
```
idle → loading → ready
                ↘ error → (retry) → loading
```

**内部動作**:
1. `useEffect` で Worker を生成
2. `Comlink.wrap()` で API プロキシを取得
3. `wrapProxy()` で安全に state 保持
4. `retry()` で Worker を破棄・再生成

### F-12: 関数別 Hook ファクトリ

**概要**: 生成コードで使われる Hook ファクトリ。各ブリッジ関数の呼び出し・結果・エラー・ローディング状態を管理する。

**公開 API**:
```typescript
function createBridgeHook<TParams, TResult>(
  methodName: string
): (api: Remote<BridgeAPI> | null, status: PyodideStatus) => {
  result: TResult | null
  error: BridgeError | null
  isLoading: boolean
  execute: (params: TParams) => Promise<void>
}
```

## 3. 画面/インターフェース設計

本ライブラリは CLI ツール + ランタイムライブラリであり、GUI は持たない。

### CLI インターフェース

```
pyodide-bridge gen [options]

Options:
  --input <path>       Python ソースファイル (設定ファイル使用時は不要)
  --outdir <path>      出力ディレクトリ (設定ファイル使用時は不要)
  --config <path>      設定ファイルパス (default: ./pyodide-bridge.config.ts)
  --pyodide-version    Pyodide バージョン (default: 設定ファイルの値)
  --bundler            バンドラー種別: vite | webpack | inline
  --no-react           React Hooks を生成しない
  --check              生成ファイルの最新性チェック (CI 用)
  --verbose            詳細ログ出力
```

### npm パッケージエントリポイント

```json
{
  "exports": {
    ".": "./dist/index.js",
    "./runtime": "./dist/runtime/index.js",
    "./react": "./dist/react/index.js"
  },
  "bin": {
    "pyodide-bridge": "./dist/cli/bin.js"
  }
}
```

## 4. エラーハンドリング方針

### CLI エラー

| エラー種別 | 対応 |
|-----------|------|
| Python ファイルが存在しない | エラーメッセージ + 終了コード 1 |
| Python 構文エラー | パーサーエラーメッセージ（行番号付き）+ 終了コード 1 |
| python3 が見つからない | インストール案内メッセージ + 終了コード 1 |
| 出力ディレクトリが存在しない | 自動作成 |
| 設定ファイルの形式エラー | バリデーションエラー詳細 + 終了コード 1 |

### ランタイムエラー

| エラー種別 | 対応 |
|-----------|------|
| Pyodide CDN ロード失敗 | `usePyodide` が `status: 'error'` + `error` を返す |
| パッケージインストール失敗 | 同上 |
| Python 実行時エラー | `BridgeError` として throw |
| エラー辞書パターン | `BridgeError(code, message)` として throw |
| Comlink 通信エラー | 関数別 Hook の `error` に設定 |
