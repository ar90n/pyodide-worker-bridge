// generated by pyodide-bridge (DO NOT EDIT)

import * as Comlink from "comlink";
import { bootstrapPyodide, deepConvertMaps, detectBridgeError } from "pyodide-bridge/runtime";

import pythonSource from "./science.py?raw";

import type {
  SignalParams,
  SignalResult,
  FilterParams,
  FilterResult,
  PlotParams,
  PlotResult,
} from "./science.types.js";

export interface BridgeAPI {
  generate_signal(params: SignalParams): Promise<SignalResult>;
  filter_signal(params: FilterParams): Promise<FilterResult>;
  plot_signal(params: PlotParams): Promise<PlotResult>;
}

let pyodide: Awaited<ReturnType<typeof bootstrapPyodide>>;

async function init(): Promise<void> {
  pyodide = await bootstrapPyodide({
    pyodideVersion: "0.27.5",
    packages: ["numpy", "scipy", "matplotlib"],
    pythonSource,
  });
}

const api: BridgeAPI = {
  async generate_signal(params: SignalParams): Promise<SignalResult> {
    const globals = pyodide.globals;
    const pyFunc = globals.get("generate_signal");
    const pyResult = pyFunc(pyodide.toPy(params));
    const jsResult = deepConvertMaps<SignalResult>(pyResult.toJs());
    detectBridgeError(jsResult);
    return jsResult;
  },
  async filter_signal(params: FilterParams): Promise<FilterResult> {
    const globals = pyodide.globals;
    const pyFunc = globals.get("filter_signal");
    const pyResult = pyFunc(pyodide.toPy(params));
    const jsResult = deepConvertMaps<FilterResult>(pyResult.toJs());
    detectBridgeError(jsResult);
    return jsResult;
  },
  async plot_signal(params: PlotParams): Promise<PlotResult> {
    const globals = pyodide.globals;
    const pyFunc = globals.get("plot_signal");
    const pyResult = pyFunc(pyodide.toPy(params));
    const jsResult = deepConvertMaps<PlotResult>(pyResult.toJs());
    detectBridgeError(jsResult);
    return jsResult;
  },
};

init().then(() => {
  Comlink.expose(api);
});
