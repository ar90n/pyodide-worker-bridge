/**
 * Hooks emitter: generates .hooks.ts from ModuleIR (React).
 */
import type { ModuleIR, FunctionNode } from "../../types.js";
import { emitTypeRef, collectReferenceTypes } from "./types.js";

const HEADER = "// generated by pyodide-bridge (DO NOT EDIT)\n";

export function emitHooks(ir: ModuleIR): string {
  const lines: string[] = [HEADER];

  // Imports
  lines.push('import { usePyodide, createBridgeHook } from "pyodide-bridge/react";');
  lines.push(`import type { BridgeAPI } from "./${ir.moduleName}.worker.js";`);

  // Collect type imports needed for function params/returns
  const typeImports: string[] = [];
  for (const func of ir.functions) {
    for (const param of func.params) {
      collectReferenceTypes(param.type, typeImports);
    }
    collectReferenceTypes(func.returnType, typeImports);
  }
  const uniqueImports = [...new Set(typeImports)];
  if (uniqueImports.length > 0) {
    lines.push(`import type { ${uniqueImports.join(", ")} } from "./${ir.moduleName}.types.js";`);
  }

  lines.push("");

  // Re-export usePyodide with correct BridgeAPI type
  lines.push("export { usePyodide };");
  lines.push("export type { BridgeAPI };");
  lines.push("");

  // Generate a hook for each exported function
  for (const func of ir.functions) {
    lines.push(emitFunctionHook(func, ir.moduleName));
    lines.push("");
  }

  return lines.join("\n");
}

function emitFunctionHook(func: FunctionNode, _moduleName: string): string {
  const hookName = `use${toPascalCase(func.name)}`;
  const paramsType =
    func.params.length === 1 ? emitTypeRef(func.params[0].type) : "void";
  const returnType = emitTypeRef(func.returnType);

  const lines: string[] = [];
  lines.push(
    `export const ${hookName} = createBridgeHook<BridgeAPI, ${paramsType}, ${returnType}>("${func.name}");`,
  );

  return lines.join("\n");
}

function toPascalCase(name: string): string {
  return name
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

