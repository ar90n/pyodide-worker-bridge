/**
 * Types emitter: generates .types.ts from ModuleIR.
 */
import type { ModuleIR, TypeNode, TypeRef, FieldNode } from "../../types.js";

const HEADER = "// generated by pyodide-bridge (DO NOT EDIT)\n";

export function emitTypes(ir: ModuleIR): string {
  const lines: string[] = [HEADER];

  for (const typeNode of ir.types) {
    lines.push(emitTypeNode(typeNode));
    lines.push("");
  }

  return lines.join("\n");
}

function emitTypeNode(node: TypeNode): string {
  switch (node.kind) {
    case "literal":
      return emitLiteralAlias(node.name, node.values);
    case "typeddict":
      return emitTypeDictType(node.name, node.fields);
  }
}

function emitLiteralAlias(name: string, values: (string | number | boolean)[]): string {
  const union = values.map((v) => (typeof v === "string" ? `"${v}"` : String(v))).join(" | ");
  return `export type ${name} = ${union};`;
}

function emitTypeDictType(name: string, fields: FieldNode[]): string {
  if (fields.length === 0) {
    return `export type ${name} = Record<string, never>;`;
  }

  const fieldLines = fields.map((f) => {
    const optional = f.required ? "" : "?";
    const tsType = emitTypeRef(f.type);
    return `  ${f.name}${optional}: ${tsType};`;
  });

  return `export type ${name} = {\n${fieldLines.join("\n")}\n};`;
}

export function emitTypeRef(ref: TypeRef): string {
  switch (ref.kind) {
    case "primitive":
      return mapPrimitive(ref.name);
    case "list":
      return `${emitTypeRef(ref.element)}[]`;
    case "dict":
      return `Record<${emitTypeRef(ref.key)}, ${emitTypeRef(ref.value)}>`;
    case "optional":
      return `${emitTypeRef(ref.inner)} | undefined`;
    case "literal": {
      const union = ref.values
        .map((v) => (typeof v === "string" ? `"${v}"` : String(v)))
        .join(" | ");
      return union;
    }
    case "reference":
      return ref.name;
  }
}

/**
 * Recursively collects referenced type names from a TypeRef tree.
 * Used by hooks and worker emitters to determine type imports.
 */
export function collectReferenceTypes(ref: TypeRef, result: string[]): void {
  switch (ref.kind) {
    case "reference":
      result.push(ref.name);
      break;
    case "list":
      collectReferenceTypes(ref.element, result);
      break;
    case "dict":
      collectReferenceTypes(ref.key, result);
      collectReferenceTypes(ref.value, result);
      break;
    case "optional":
      collectReferenceTypes(ref.inner, result);
      break;
  }
}

function mapPrimitive(name: string): string {
  switch (name) {
    case "int":
    case "float":
      return "number";
    case "str":
      return "string";
    case "bool":
      return "boolean";
    case "None":
      return "null";
    default:
      return "unknown";
  }
}
