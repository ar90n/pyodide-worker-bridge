/**
 * Worker emitter: generates .worker.ts from ModuleIR.
 */
import type { ModuleIR, FunctionNode } from "../../types.js";
import { emitTypeRef, collectReferenceTypes } from "./types.js";

export interface WorkerEmitterOptions {
  /** Pyodide CDN version */
  pyodideVersion: string;
  /** Bundler type for Python source import strategy */
  bundler: "vite" | "webpack" | "inline";
  /** Relative path from worker to the Python source file */
  pythonSourcePath?: string;
}

const HEADER = "// generated by pyodide-bridge (DO NOT EDIT)\n";

export function emitWorker(ir: ModuleIR, options: WorkerEmitterOptions): string {
  const { pyodideVersion, bundler } = options;
  const lines: string[] = [HEADER];

  // Imports
  lines.push('import * as Comlink from "comlink";');
  lines.push(
    'import { bootstrapPyodide, deepConvertMaps, detectBridgeError } from "pyodide-bridge/runtime";',
  );

  // Python source import based on bundler
  const pythonSourcePath = options.pythonSourcePath || `./${ir.moduleName}.py`;
  lines.push("");
  switch (bundler) {
    case "vite":
      lines.push(`import pythonSource from "${pythonSourcePath}?raw";`);
      break;
    case "webpack":
      lines.push(`import pythonSource from "!!raw-loader!${pythonSourcePath}";`);
      break;
    case "inline":
      lines.push("// Python source is embedded inline (see below)");
      lines.push("const pythonSource = `# inline Python source placeholder`;");
      break;
  }

  lines.push("");

  // Type imports from generated types file
  const typeImports: string[] = [];
  for (const func of ir.functions) {
    for (const param of func.params) {
      collectReferenceTypes(param.type, typeImports);
    }
    collectReferenceTypes(func.returnType, typeImports);
  }
  const uniqueImports = [...new Set(typeImports)];
  if (uniqueImports.length > 0) {
    lines.push(`import type { ${uniqueImports.join(", ")} } from "./${ir.moduleName}.types.js";`);
    lines.push("");
  }

  // API interface
  lines.push("export interface BridgeAPI {");
  for (const func of ir.functions) {
    const paramsStr = func.params.map((p) => `${p.name}: ${emitTypeRef(p.type)}`).join(", ");
    const returnStr = emitTypeRef(func.returnType);
    lines.push(`  ${func.name}(${paramsStr}): Promise<${returnStr}>;`);
  }
  lines.push("}");
  lines.push("");

  // Worker initialization
  lines.push("let pyodide: Awaited<ReturnType<typeof bootstrapPyodide>>;");
  lines.push("");
  lines.push("async function init(): Promise<void> {");
  lines.push("  pyodide = await bootstrapPyodide({");
  lines.push(`    pyodideVersion: "${pyodideVersion}",`);
  lines.push(`    packages: ${JSON.stringify(ir.packages)},`);
  lines.push("    pythonSource,");
  lines.push("  });");
  lines.push("}");
  lines.push("");

  // API implementation
  lines.push("const api: BridgeAPI = {");
  for (let i = 0; i < ir.functions.length; i++) {
    const func = ir.functions[i];
    const comma = i < ir.functions.length - 1 ? "," : "";
    lines.push(emitFunctionImpl(func) + comma);
  }
  lines.push("};");
  lines.push("");

  // Init and expose
  lines.push("init().then(() => {");
  lines.push("  Comlink.expose(api);");
  lines.push("});");
  lines.push("");

  return lines.join("\n");
}

function emitFunctionImpl(func: FunctionNode): string {
  const paramsStr = func.params.map((p) => `${p.name}: ${emitTypeRef(p.type)}`).join(", ");
  const returnStr = emitTypeRef(func.returnType);
  const paramNames = func.params.map((p) => p.name);

  const implLines: string[] = [];
  implLines.push(`  async ${func.name}(${paramsStr}): Promise<${returnStr}> {`);
  implLines.push(`    const globals = pyodide.globals;`);
  implLines.push(`    const pyFunc = globals.get("${func.name}");`);

  if (paramNames.length === 1) {
    implLines.push(`    const pyResult = pyFunc(pyodide.toPy(${paramNames[0]}));`);
  } else if (paramNames.length === 0) {
    implLines.push(`    const pyResult = pyFunc();`);
  } else {
    implLines.push(
      `    const pyResult = pyFunc(${paramNames.map((n) => `pyodide.toPy(${n})`).join(", ")});`,
    );
  }

  implLines.push(`    const jsResult = deepConvertMaps<${returnStr}>(pyResult.toJs());`);
  implLines.push(`    detectBridgeError(jsResult);`);
  implLines.push(`    return jsResult;`);
  implLines.push(`  }`);

  return implLines.join("\n");
}
